{"name":"jQuery.websocks","tagline":"warm socks for JavaScript WebSocket","body":"jquery.websocks.js plugin\r\n=========================\r\n\r\n[jquery.websocks.js](http://github.com) - warm socks for JavaScript WebSocket.\r\n\r\nThin wrapper (and drop-in replacement) for JavaScript WebSocket.\r\n\r\nWhy another WebSocket wrapper?\r\n------------------------------\r\n\r\nBecause, in my humble opinion, the original JavaScript WebSocket API is horribly designed!\r\n\r\nBy searching the web, you can find that you should use WebSocket API like this:\r\n\r\n```js\r\nvar ws = new WebSocket('ws://some_url/to/websocket');\r\nws.onmessage = function (event) { do_something_with(event) };\r\nws.onclose = function (event) { do_something_with(event) };\r\n\r\n// ... and so on with the rest of callbacks ...\r\n```\r\n\r\nEverything works, no one dies, we're fine.\r\n\r\nBut...\r\n\r\nHow we can be sure that we didn't miss some messages from the server?\r\nThe WebSocket is connecting during the construction, and we are defining the ```.onmessage``` afterwards...\r\nWhat if we will encounter some \"blocking\" event between ```new WebSocket``` and setting ```.onmessage```? Or our JS thread in the browser will be stuck for some other reason?\r\n\r\nIt should be done like in this plugin (by providing the callbacks during construction) or there should be ```.connect()``` function/method which should be called after setting the callbacks explicitly by the programmer.\r\n\r\nAnyway, besides the technical problems which may pop out, the original WebSocket API looks illogical for the technical guys (I'm assuming that the JS programmers are)...\r\n\r\nAbout the other WebSocket wrappers which i found on the web, most of them have hardcoded JSON/XML/base64 serialization. This approach allows you to define yours with additional benefits.\r\n\r\nRequirements\r\n------------\r\n\r\n[jQuery](http://jquery.com/) (tested on v2.0.3 but should work without glitches on older versions too)\r\n\r\nFeatures\r\n--------\r\n\r\nSame as original JavaScript WebSocket and additionally:\r\n\r\n* keepalive\r\n* automatic serialization and deserialization\r\n* automatic disconnection (when closing window)\r\n\r\nInstallation\r\n------------\r\n\r\nJust put it somewhere on your web server and load it into your web page.\r\n\r\nUsage\r\n-----\r\n\r\n```js\r\nvar websocket = $.websocks(\"ws://your/websocket/socket\", options);\r\n```\r\n\r\nIt returns (almost) plain, native JavaScript WebSocket object.\r\n\r\nOptions\r\n-------\r\n\r\nThese are the default values\r\n\r\n```js\r\noptions = {\r\n    protocols: [],\r\n\r\n    keepAlive: false,\r\n    keepAliveInterval: 10000,\r\n    keepAliveMessage: '_KEEP_ALIVE_',\r\n\r\n    serializer: {\r\n        encode: function () {},\r\n        decode: function () {},\r\n    },\r\n\r\n    onopen:     function() {},\r\n    onmessage:  function() {},\r\n    onerror:    function() {},\r\n    onclose:    function() {},\r\n\r\n};\r\n```\r\n\r\n- ```protocols``` - same as second parameter of original WebSocket (default: None),\r\n- ```keepAlive``` - if true turns on the \"Poor's man keep alive\",\r\n- ```keepAliveInterval``` - how often send keep alive packet to the server in milliseconds (default: 10000),\r\n- ```KeepAliveMessage``` - the contents of the message which will be sent to server (default: _KEEP_ALIVE_),\r\n- ```serializer``` - simple object with two functions:\r\n  - ```encode``` - to encode the message prior to sending,\r\n  - ```decode``` - to decode the message after getting it from the server,\r\n- ```onopen```, ```onmessage```, ```onerror```, ```onclose``` - callback functions which will be triggered when certain event will happen (same like in original WebSocket, with small exception - see below).\r\n\r\nEvent callbacks\r\n---------------\r\n\r\n```onopen```, ```onmessage```, ```onerror```, ```onclose```\r\n\r\nAll of those functions work exactly like original JavaScript WebSocket, with small exception; they add another argument at the end which will contain decoded/deserialized data.\r\n\r\nExample:\r\n\r\n```js\r\non message = function (e, decoded_data) {\r\n    console.log(\"Event\" + e);\r\n    console.log(\"Original data is: \" + e.data);\r\n    console.log(\"Decoded data \" + decoded_data);\r\n}\r\n```\r\n\r\nAdditional function(s)\r\n----------------------\r\n\r\n```.esend(data)``` - acts exactly the same way as original ```.send(data)``` but uses serializer.encode prior to sending.\r\n\r\nExample:\r\n\r\n```js\r\nwebsocks.esend(\"message in the bottle\"); // Encodes and sends message to the web socket server\r\n```\r\n\r\nTODO\r\n----\r\n\r\n- automagic reconnect,\r\n- plain js Object instead of jQuery wrapper/plugin\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}